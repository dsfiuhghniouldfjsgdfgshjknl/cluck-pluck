<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cluck & Pluck: Poultry Wellness Simulator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <link rel="icon" type="image/x-icon" href="Chick.ico">
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; touch-action: none; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CLUCK & PLUCK: POULTRY WELLNESS SIMULATOR
// "Where Every Squeeze Counts‚Ñ¢"
// Version 2.2.0 - Now Mobile Responsive (HR Approved)
// USDA compliance pending
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üéµ MUSIC CONFIGURATION - Add your tracks here! üéµ
// Supported: MP3, OGG, WAV URLs
// Pro tip: Elevator music increases productivity by 420%
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MUSIC_TRACKS = [
  "01Silent.mp3",
  "music/02Silent.mp3",
  "music/03Silent.mp3",
  // Add your local music files here (place them in the same folder as this HTML file)
  // Examples:
  // "music/elevator-music.mp3",
  // "background.ogg",
  // "sounds/corporate-jingle.wav",
  //
  // Folder structure example:
  // üìÅ my-game-folder/
  //    üìÑ index.html (this file)
  //    üéµ background.mp3
  //    üìÅ music/
  //       üéµ track1.mp3
  //       üéµ track2.mp3
];
const MUSIC_VOLUME = 0.2; // 0.0 to 1.0 - Corporate mandated levels
const FADE_DURATION = 2000; // Fade in/out duration in ms - smooth transitions for sensitive chickens
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let satisfaction = 0;
let chickenShake = 0;
let bananaShake = 0;
let intensityLevel = 0;
let hasBanana = false;
let devicesPaired = false;
let dualModeStartTime = 0;
let showShop = false;
let achievements = [];
let achievementQueue = [];
let currentAchievementDisplay = null;
let achievementTimer = 0;
let activateBtnPressed = false;

// NEW: Phone hide/show functionality
let phoneHidden = false;
let phoneHideProgress = 0;
const PHONE_HIDE_SPEED = 0.1;

// Responsive scaling - one size fits all farm equipment
let scaleFactor = 1;
let isMobile = false;
let phoneX, phoneY, phoneW, phoneH;
let chickenX, chickenY, chickenScale;
let bananaX, bananaY;

// Target positions for animation
let targetPhoneX, targetChickenX, targetChickenY, targetBananaX, targetBananaY;
let originalPhoneX, originalChickenX, originalChickenY, originalBananaX, originalBananaY;

// Current positions for click detection
let currentPhoneX, currentChickenX, currentChickenY, currentBananaX, currentBananaY;

// Audio systems - farm-grade frequencies
let audioCtx = null;
let musicPlayer = null;
let currentTrackIndex = 0;
let musicPlaying = false;

const reviews = [
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "Finally, an app that respects my lifestyle" - ChickenEnthusiast42',
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "Banana pairing works flawlessly, 10/10 immersion" - WellnessGuru99',
  '‚≠ê "My chicken hasn\'t laid eggs since update 1.4. Please fix" - FrustratedFarmer',
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "The Thanksgiving Panic mode changed my life" - GratefulUser',
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "I use this app 8 hours day. My employer is concerned" - Anonymous',
  '‚≠ê‚≠ê‚≠ê‚≠ê "Would give 5 stars but chicken looked at me weird" - NervousNancy',
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "Better than actual therapy" - DrFeelgood_MD',
  '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê "The USDA called. I didn\'t answer" - RebelFarmer2024'
];
let reviewScroll = 0;

const intensityLabels = ["Gentle Caress", "Morning Stretch", "Angry Rooster", "Thanksgiving Panic"];
const intensityMultipliers = [1, 2, 4, 8];

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont('Segoe UI');
  calculateLayout();
  
  // Store original positions for animation
  storeOriginalPositions();
  
  // Initialize music player if tracks exist
  if (MUSIC_TRACKS.length > 0) {
    musicPlayer = document.createElement('audio');
    musicPlayer.volume = 0;
    musicPlayer.loop = false;
    // Fade out before switching tracks - corporate-grade transitions
    musicPlayer.onended = () => fadeOut(() => playNextTrack());
  }
}

// Store original positions for animation
function storeOriginalPositions() {
  originalPhoneX = phoneX;
  originalChickenX = chickenX;
  originalChickenY = chickenY;
  originalBananaX = bananaX;
  originalBananaY = bananaY;
}

// Calculate target positions for hide/show animation
function calculateTargetPositions() {
  if (isMobile) {
    // Mobile: phone slides left, chicken and banana move to center
    targetPhoneX = -phoneW - 50;
    targetChickenX = width / 2;
    targetChickenY = height / 2 - 50;
    targetBananaX = width / 2;
    targetBananaY = height / 2 + 100;
  } else {
    // Desktop: phone slides left, chicken and banana move to center-left
    targetPhoneX = -phoneW - 50;
    targetChickenX = width / 2 - 100;
    targetChickenY = height / 2;
    targetBananaX = width / 2 + 100;
    targetBananaY = height / 2;
  }
}

// Responsive layout calculator - fits all screen sizes from phone to jumbotron
function calculateLayout() {
  isMobile = width < 600;
  
  if (isMobile) {
    // Mobile: stack vertically, phone UI on top
    scaleFactor = min(width / 320, 1.2);
    // CHANGED: Slightly shrink phone by reducing the multiplier from 0.9 to 0.8
    phoneW = min(width * 0.8, 280 * scaleFactor * 0.9); // Reduced size for better chicken visibility
    phoneH = phoneW * 1.6;
    phoneX = (width - phoneW) / 2;
    phoneY = 10;
    
    // Chicken below phone UI - adjusted spacing due to smaller phone
    chickenScale = scaleFactor * 0.9; // Slightly larger chicken
    chickenX = width / 2;
    chickenY = phoneY + phoneH + 60 * scaleFactor; // Reduced gap since phone is smaller
    
    bananaX = width / 2;
    bananaY = chickenY + 120 * scaleFactor;
  } else {
    // Desktop/tablet: side by side
    scaleFactor = min(height / 600, width / 900, 1.3);
    phoneW = 280 * scaleFactor;
    phoneH = 500 * scaleFactor;
    phoneX = 30 * scaleFactor;
    phoneY = (height - phoneH) / 2;
    
    chickenScale = scaleFactor;
    chickenX = width / 2 + 50 * scaleFactor;
    chickenY = height / 2;
    
    bananaX = chickenX + 200 * scaleFactor;
    bananaY = chickenY + 50 * scaleFactor;
  }
  
  // Update original positions and calculate targets
  storeOriginalPositions();
  calculateTargetPositions();
}

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  
  // Start background music on first interaction
  if (MUSIC_TRACKS.length > 0 && !musicPlaying) {
    playNextTrack();
    musicPlaying = true;
  }
}

function playNextTrack() {
  if (MUSIC_TRACKS.length === 0 || !musicPlayer) return;
  musicPlayer.src = MUSIC_TRACKS[currentTrackIndex];
  musicPlayer.volume = 0;
  musicPlayer.play().then(() => fadeIn()).catch(e => console.log("Music autoplay blocked - click to enable"));
  currentTrackIndex = (currentTrackIndex + 1) % MUSIC_TRACKS.length;
}

// Smooth fade in - gentle on chicken ears
function fadeIn() {
  if (!musicPlayer) return;
  let startTime = Date.now();
  let fadeInInterval = setInterval(() => {
    let elapsed = Date.now() - startTime;
    let progress = Math.min(elapsed / FADE_DURATION, 1);
    musicPlayer.volume = progress * MUSIC_VOLUME;
    if (progress >= 1) clearInterval(fadeInInterval);
  }, 50);
}

// Smooth fade out - prepares flock for track transition
function fadeOut(callback) {
  if (!musicPlayer) { if (callback) callback(); return; }
  let startTime = Date.now();
  let startVolume = musicPlayer.volume;
  let fadeOutInterval = setInterval(() => {
    let elapsed = Date.now() - startTime;
    let progress = Math.min(elapsed / FADE_DURATION, 1);
    musicPlayer.volume = startVolume * (1 - progress);
    if (progress >= 1) {
      clearInterval(fadeOutInterval);
      if (callback) callback();
    }
  }, 50);
}

function playBeep(freq, duration, type = 'sine') {
  if (!audioCtx) return;
  let osc = audioCtx.createOscillator();
  let gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playWellnessSound() {
  if (!audioCtx) return;
  let baseFreq = 200 + intensityLevel * 100;
  playBeep(baseFreq + Math.random() * 100 - 50, 0.15);
}

function playPairingSound() {
  if (!audioCtx) return;
  [523, 659, 784, 1047].forEach((freq, i) => {
    setTimeout(() => playBeep(freq, 0.2), i * 150);
  });
}

function draw() {
  background(255, 245, 230);
  drawFarmBackground();
  
  // Update animation progress
  if (phoneHidden && phoneHideProgress < 1) {
    phoneHideProgress = min(phoneHideProgress + PHONE_HIDE_SPEED, 1);
  } else if (!phoneHidden && phoneHideProgress > 0) {
    phoneHideProgress = max(phoneHideProgress - PHONE_HIDE_SPEED, 0);
  }
  
  // Calculate current positions based on animation progress
  if (phoneHideProgress === 0) {
    // Phone visible - use original positions
    currentPhoneX = originalPhoneX;
    currentChickenX = originalChickenX;
    currentChickenY = originalChickenY;
    currentBananaX = originalBananaX;
    currentBananaY = originalBananaY;
  } else if (phoneHideProgress === 1) {
    // Phone hidden - use target positions
    currentPhoneX = targetPhoneX;
    currentChickenX = targetChickenX;
    currentChickenY = targetChickenY;
    currentBananaX = targetBananaX;
    currentBananaY = targetBananaY;
  } else {
    // In between - interpolate
    currentPhoneX = lerp(originalPhoneX, targetPhoneX, phoneHideProgress);
    currentChickenX = lerp(originalChickenX, targetChickenX, phoneHideProgress);
    currentChickenY = lerp(originalChickenY, targetChickenY, phoneHideProgress);
    currentBananaX = lerp(originalBananaX, targetBananaX, phoneHideProgress);
    currentBananaY = lerp(originalBananaY, targetBananaY, phoneHideProgress);
  }
  
  // Draw elements with current positions
  drawChicken(currentChickenX, currentChickenY);
  if (hasBanana) drawBanana(currentBananaX, currentBananaY);
  
  // Only draw phone if not completely hidden or in transition
  if (phoneHideProgress < 1) {
    drawPhoneUI(currentPhoneX, phoneY);
  }
  
  // Draw show/hide phone button
  drawPhoneToggleButton();
  
  if (showShop) drawShop();
  updateAchievements();
  drawReviews();
  if (MUSIC_TRACKS.length > 0) drawMusicIndicator();
  
  chickenShake *= 0.9;
  bananaShake *= 0.9;
  activateBtnPressed = false;
  
  if (devicesPaired && dualModeStartTime > 0) {
    let elapsed = (millis() - dualModeStartTime) / 1000;
    if (elapsed < 30 && !achievements.includes("USDA Violation Speedrun")) {
      unlockAchievement("USDA Violation Speedrun");
    }
  }
}

function drawMusicIndicator() {
  let sz = 20 * scaleFactor;
  fill(180, 150, 220);
  noStroke();
  ellipse(width - 30 * scaleFactor, height - 70 * scaleFactor, sz * 2);
  fill(255);
  textSize(sz);
  textAlign(CENTER, CENTER);
  text(musicPlaying ? "‚ô™" : "‚ô™", width - 30 * scaleFactor, height - 70 * scaleFactor);
}

function drawFarmBackground() {
  fill(200, 230, 200);
  noStroke();
  ellipse(width * 0.2, height + 50, 400 * scaleFactor, 200 * scaleFactor);
  ellipse(width * 0.7, height + 30, 500 * scaleFactor, 180 * scaleFactor);
  fill(255, 255, 255, 200);
  ellipse(100 * scaleFactor, 80 * scaleFactor, 80 * scaleFactor, 50 * scaleFactor);
  ellipse(130 * scaleFactor, 70 * scaleFactor, 60 * scaleFactor, 40 * scaleFactor);
}

function drawChicken(currentX, currentY) {
  push();
  translate(currentX + random(-chickenShake, chickenShake), currentY + random(-chickenShake * 0.5, chickenShake * 0.5));
  scale(chickenScale);
  
  fill(255, 248, 220);
  stroke(200, 180, 150);
  strokeWeight(3);
  ellipse(0, 0, 160, 140);
  
  fill(255, 240, 200);
  ellipse(-40, 10, 50, 70);
  
  fill(255, 248, 220);
  ellipse(50, -50, 80, 70);
  
  fill(255, 180, 50);
  noStroke();
  triangle(85, -50, 115, -45, 85, -40);
  
  fill(220, 60, 60);
  beginShape();
  vertex(30, -85); vertex(40, -70); vertex(50, -90);
  vertex(60, -70); vertex(70, -85); vertex(65, -65); vertex(35, -65);
  endShape(CLOSE);
  ellipse(75, -30, 15, 25);
  
  fill(255);
  stroke(200, 180, 150);
  strokeWeight(2);
  ellipse(55, -55, 25, 28);
  ellipse(75, -55, 25, 28);
  
  fill(0);
  noStroke();
  let pupilOffset = sin(frameCount * 0.05) * 3;
  ellipse(58 + pupilOffset, -53, 10, 12);
  ellipse(78 + pupilOffset, -53, 10, 12);
  
  stroke(100, 80, 60);
  strokeWeight(3);
  noFill();
  line(45, -70, 65, -65);
  line(70, -65, 90, -70);
  
  stroke(255, 180, 50);
  strokeWeight(5);
  line(-20, 65, -30, 110);
  line(20, 65, 30, 110);
  line(-30, 110, -45, 115);
  line(-30, 110, -25, 120);
  line(30, 110, 45, 115);
  line(30, 110, 25, 120);
  
  if (intensityLevel >= 2) {
    fill(150, 200, 255);
    noStroke();
    ellipse(95, -35, 8, 12);
  }
  pop();
}

function drawBanana(currentX, currentY) {
  push();
  translate(currentX + random(-bananaShake, bananaShake), currentY + random(-bananaShake * 0.5, bananaShake * 0.5));
  scale(chickenScale);
  rotate(-0.3);
  
  fill(255, 230, 50);
  stroke(200, 180, 30);
  strokeWeight(3);
  beginShape();
  vertex(-60, 0);
  bezierVertex(-70, -40, 0, -60, 60, -30);
  bezierVertex(80, -20, 80, 20, 60, 30);
  bezierVertex(0, 50, -70, 30, -60, 0);
  endShape(CLOSE);
  
  fill(139, 90, 43);
  noStroke();
  rect(-70, -10, 15, 20, 5);
  
  fill(50);
  textSize(12);
  textAlign(CENTER);
  text("3000", 0, 5);
  
  if (devicesPaired) {
    fill(0, 255, 100);
    ellipse(40, 0, 10, 10);
  }
  pop();
}

// NEW: Draw the phone toggle button
function drawPhoneToggleButton() {
  let btnSize = 50 * scaleFactor;
  let btnX, btnY;
  
  if (phoneHidden) {
    // Show button on left side when phone is hidden
    btnX = 10;
    btnY = height - btnSize - 40;
  } else {
    // Hide button at bottom of phone
    let s = phoneW / 280;
    let btnYPhone = phoneY + 215 * s;
    let btnH = max(45 * s, 44);
    btnX = phoneX + 25 * s;
    btnY = btnYPhone + btnH + 100 * s;
  }
  
  fill(120, 120, 200);
  stroke(90, 90, 180);
  strokeWeight(2);
  rect(btnX, btnY, phoneHidden ? btnSize * 1.5 : phoneW - 50 * (phoneW/280), 35 * scaleFactor, 8 * scaleFactor);
  
  fill(255);
  textSize(12 * scaleFactor);
  textAlign(CENTER, CENTER);
  text(phoneHidden ? "Show Phone" : "üëÅÔ∏è Hide Phone", 
       btnX + (phoneHidden ? btnSize * 0.75 : (phoneW - 50 * (phoneW/280)) / 2), 
       btnY + 17.5 * scaleFactor);
  
  // Store button position for click detection
  window.phoneToggleBtn = {
    x: btnX, 
    y: btnY, 
    w: phoneHidden ? btnSize * 1.5 : phoneW - 50 * (phoneW/280), 
    h: 35 * scaleFactor
  };
}

function drawPhoneUI(currentX, currentY) {
  let s = phoneW / 280; // Scale factor relative to base size
  
  fill(60, 60, 70);
  stroke(100, 100, 110);
  strokeWeight(3);
  rect(currentX, currentY, phoneW, phoneH, 25 * s);
  
  fill(250, 245, 255);
  noStroke();
  rect(currentX + 10 * s, currentY + 40 * s, phoneW - 20 * s, phoneH - 80 * s, 15 * s);
  
  fill(180, 150, 220);
  rect(currentX + 10 * s, currentY + 40 * s, phoneW - 20 * s, 50 * s, 15 * s, 15 * s, 0, 0);
  fill(255);
  textSize(18 * s);
  textAlign(CENTER);
  textStyle(BOLD);
  text("CluckControl Pro‚Ñ¢", currentX + phoneW / 2, currentY + 72 * s);
  
  textStyle(NORMAL);
  fill(80);
  textSize(12 * s);
  textAlign(LEFT);
  text("Chicken Satisfaction‚Ñ¢", currentX + 25 * s, currentY + 115 * s);
  
  fill(220);
  rect(currentX + 25 * s, currentY + 125 * s, phoneW - 50 * s, 25 * s, 12 * s);
  
  let fillWidth = map(constrain(satisfaction, 0, 10000), 0, 10000, 0, phoneW - 54 * s);
  fill(lerpColor(color(255, 150, 150), color(150, 255, 150), satisfaction / 10000));
  rect(currentX + 27 * s, currentY + 127 * s, fillWidth, 21 * s, 10 * s);
  
  fill(80);
  textAlign(RIGHT);
  text(floor(satisfaction) + " pts", currentX + phoneW - 25 * s, currentY + 143 * s);
  
  textAlign(LEFT);
  text("Wellness Intensity‚Ñ¢", currentX + 25 * s, currentY + 180 * s);
  
  let btnW = (phoneW - 50 * s - 15 * s) / 4;
  for (let i = 0; i < 4; i++) {
    let bx = currentX + 25 * s + i * (btnW + 5 * s);
    let by = currentY + 190 * s;
    fill(i === intensityLevel ? color(180, 150, 220) : 240);
    stroke(i === intensityLevel ? color(140, 110, 180) : 200);
    strokeWeight(2);
    rect(bx, by, btnW, 45 * s, 8 * s);
    
    fill(i === intensityLevel ? 255 : 80);
    noStroke();
    textAlign(CENTER);
    textSize(8 * s);
    let lines = intensityLabels[i].split(" ");
    for (let j = 0; j < lines.length; j++) {
      text(lines[j], bx + btnW / 2, by + 15 * s + j * 12 * s);
    }
  }
  
  let btnY = currentY + 260 * s;
  let btnH = max(45 * s, 44);
  
  // ACTIVATE WELLNESS button with press state
  fill(activateBtnPressed ? color(70, 170, 120) : color(100, 200, 150));
  stroke(70, 170, 120);
  strokeWeight(2);
  rect(currentX + 25 * s, btnY, phoneW - 50 * s, btnH, 10 * s);
  fill(255);
  textSize(14 * s);
  textStyle(BOLD);
  textAlign(CENTER);
  text("ACTIVATE WELLNESS", currentX + phoneW / 2, btnY + btnH / 2 + 5 * s);
  
  textStyle(NORMAL);
  fill(255, 200, 100);
  stroke(230, 170, 70);
  rect(currentX + 25 * s, btnY + btnH + 10 * s, phoneW - 50 * s, 35 * s, 8 * s);
  fill(80);
  textSize(12 * s);
  text("üõí Premium Shop", currentX + phoneW / 2, btnY + btnH + 10 * s + 22 * s);
  
  if (hasBanana && !devicesPaired) {
    fill(100, 180, 255);
    stroke(70, 150, 225);
    rect(currentX + 25 * s, btnY + btnH + 55 * s, phoneW - 50 * s, 35 * s, 8 * s);
    fill(255);
    text("üîó Pair Devices", currentX + phoneW / 2, btnY + btnH + 55 * s + 22 * s);
  } else if (devicesPaired) {
    fill(100, 255, 150);
    noStroke();
    rect(currentX + 25 * s, btnY + btnH + 55 * s, phoneW - 50 * s, 35 * s, 8 * s);
    fill(50);
    text("‚úì DUAL MODE ACTIVE", currentX + phoneW / 2, btnY + btnH + 55 * s + 22 * s);
  }
  
  fill(80);
  textSize(10 * s);
  textAlign(LEFT);
  text("üì∂ Farm-Fi  üîã 98%", currentX + 25 * s, currentY + phoneH - 25 * s);
  textSize(8 * s);
  fill(150);
  textAlign(CENTER);
  text("¬© 2024 CluckTech Industries", currentX + phoneW / 2, currentY + phoneH - 10 * s);
}

function drawShop() {
  fill(0, 0, 0, 150);
  rect(0, 0, width, height);
  
  let shopW = min(350 * scaleFactor, width * 0.9);
  let shopH = shopW * 0.85;
  let shopX = (width - shopW) / 2;
  let shopY = (height - shopH) / 2;
  let ss = shopW / 350;
  
  fill(255);
  stroke(200);
  strokeWeight(2);
  rect(shopX, shopY, shopW, shopH, 20 * ss);
  
  fill(180, 150, 220);
  noStroke();
  rect(shopX, shopY, shopW, 50 * ss, 20 * ss, 20 * ss, 0, 0);
  
  fill(255);
  textSize(20 * ss);
  textAlign(CENTER);
  textStyle(BOLD);
  text("Premium Shop", shopX + shopW / 2, shopY + 32 * ss);
  
  textStyle(NORMAL);
  fill(80);
  textSize(16 * ss);
  text("üçå Banana Cleaner 3000‚Ñ¢", shopX + shopW / 2, shopY + 80 * ss);
  
  textSize(12 * ss);
  fill(120);
  text("Revolutionary dual-wellness technology", shopX + shopW / 2, shopY + 105 * ss);
  text("Pairs seamlessly with your chicken", shopX + shopW / 2, shopY + 125 * ss);
  
  textSize(24 * ss);
  fill(50, 150, 50);
  textStyle(BOLD);
  text("5,000 pts", shopX + shopW / 2, shopY + 165 * ss);
  
  textStyle(NORMAL);
  let canBuy = satisfaction >= 5000 && !hasBanana;
  fill(canBuy ? color(100, 200, 100) : 200);
  stroke(canBuy ? color(70, 170, 70) : 180);
  strokeWeight(2);
  rect(shopX + 50 * ss, shopY + 190 * ss, shopW - 100 * ss, 40 * ss, 10 * ss);
  
  fill(hasBanana ? 150 : (canBuy ? 255 : 150));
  textSize(14 * ss);
  text(hasBanana ? "‚úì PURCHASED" : "PURCHASE", shopX + shopW / 2, shopY + 215 * ss);
  
  fill(255, 100, 100);
  noStroke();
  ellipse(shopX + shopW - 20 * ss, shopY + 20 * ss, 30 * ss);
  fill(255);
  textSize(18 * ss);
  text("√ó", shopX + shopW - 20 * ss, shopY + 26 * ss);
}

function drawReviews() {
  let rh = 40 * scaleFactor;
  fill(240, 235, 250);
  noStroke();
  rect(0, height - rh, width, rh);
  
  fill(100);
  textSize(11 * scaleFactor);
  textAlign(LEFT);
  textStyle(NORMAL);
  
  reviewScroll += 0.5;
  let reviewText = reviews.join("     ‚Ä¢     ");
  let totalWidth = reviewText.length * 5.5 * scaleFactor;
  if (reviewScroll > totalWidth) reviewScroll = -width;
  
  text(reviewText, -reviewScroll, height - rh / 2 + 4 * scaleFactor);
  text(reviewText, -reviewScroll + totalWidth, height - rh / 2 + 4 * scaleFactor);
}

function unlockAchievement(name) {
  if (!achievements.includes(name)) {
    achievements.push(name);
    achievementQueue.push(name);
  }
}

function updateAchievements() {
  if (!currentAchievementDisplay && achievementQueue.length > 0) {
    currentAchievementDisplay = achievementQueue.shift();
    achievementTimer = 180;
  }
  
  if (currentAchievementDisplay) {
    let aw = min(300 * scaleFactor, width * 0.8);
    let ah = 60 * scaleFactor;
    let ax = width - aw - 10;
    let ay = 10;
    let slideProgress = min(1, (180 - achievementTimer) / 30);
    let slideOffset = (1 - slideProgress) * (aw + 20);
    
    push();
    translate(slideOffset, 0);
    fill(50, 50, 60);
    stroke(255, 215, 0);
    strokeWeight(3);
    rect(ax, ay, aw, ah, 10 * scaleFactor);
    
    fill(255, 215, 0);
    textSize(24 * scaleFactor);
    textAlign(LEFT);
    text("üèÜ", ax + 10 * scaleFactor, ay + ah * 0.65);
    
    fill(255);
    textSize(10 * scaleFactor);
    text("ACHIEVEMENT UNLOCKED", ax + 45 * scaleFactor, ay + 20 * scaleFactor);
    textSize(12 * scaleFactor);
    textStyle(BOLD);
    text(currentAchievementDisplay, ax + 45 * scaleFactor, ay + 42 * scaleFactor);
    textStyle(NORMAL);
    pop();
    
    achievementTimer--;
    if (achievementTimer <= 0) currentAchievementDisplay = null;
  }
}

function getButtonBounds(currentX, currentY) {
  let s = phoneW / 280;
  let btnY = currentY + 260 * s;
  let btnH = max(45 * s, 44);
  
  return {
    activate: { x: currentX + 25 * s, y: btnY, w: phoneW - 50 * s, h: btnH },
    shop: { x: currentX + 25 * s, y: btnY + btnH + 10 * s, w: phoneW - 50 * s, h: 35 * s },
    pair: { x: currentX + 25 * s, y: btnY + btnH + 55 * s, w: phoneW - 50 * s, h: 35 * s },
    intensity: []
  };
}

function hitTest(x, y, btn) {
  return x > btn.x && x < btn.x + btn.w && y > btn.y && y < btn.y + btn.h;
}

// NEW: Check if click is on chicken
function isClickOnChicken(x, y, chickenX, chickenY) {
  // Simple circle hit detection for the chicken body
  let chickenRadius = 80 * chickenScale;
  return dist(x, y, chickenX, chickenY) < chickenRadius;
}

// NEW: Check if click is on banana
function isClickOnBanana(x, y, bananaX, bananaY) {
  // Simple circle hit detection for the banana
  let bananaRadius = 60 * chickenScale;
  return dist(x, y, bananaX, bananaY) < bananaRadius;
}

function mousePressed() {
  initAudio();
  
  // NEW: Check phone toggle button first
  if (window.phoneToggleBtn && 
      mouseX > window.phoneToggleBtn.x && 
      mouseX < window.phoneToggleBtn.x + window.phoneToggleBtn.w &&
      mouseY > window.phoneToggleBtn.y && 
      mouseY < window.phoneToggleBtn.y + window.phoneToggleBtn.h) {
    phoneHidden = !phoneHidden;
    playBeep(500, 0.1);
    return;
  }
  
  // NEW: Check if clicking on chicken when phone is hidden
  if (phoneHidden) {
    if (isClickOnChicken(mouseX, mouseY, currentChickenX, currentChickenY)) {
      activateWellness();
      return;
    }
    
    // Also check if clicking on banana when paired
    if (devicesPaired && hasBanana && isClickOnBanana(mouseX, mouseY, currentBananaX, currentBananaY)) {
      activateWellness();
      return;
    }
  }
  
  // Calculate current phone position for hit testing
  let currentPhoneX = phoneHideProgress === 0 ? originalPhoneX : 
                     phoneHideProgress === 1 ? targetPhoneX :
                     lerp(originalPhoneX, targetPhoneX, phoneHideProgress);
  
  let s = phoneW / 280;
  let bounds = getButtonBounds(currentPhoneX, phoneY);
  
  // FIX: Check shop interactions first before phone UI buttons
  if (showShop) {
    let shopW = min(350 * scaleFactor, width * 0.9);
    let shopH = shopW * 0.85;
    let shopX = (width - shopW) / 2;
    let shopY = (height - shopH) / 2;
    let ss = shopW / 350;
    
    // Check for close button
    if (dist(mouseX, mouseY, shopX + shopW - 20 * ss, shopY + 20 * ss) < 20 * ss) {
      showShop = false;
      playBeep(400, 0.1);
      return;
    }
    
    // Check for purchase button
    if (mouseX > shopX + 50 * ss && mouseX < shopX + shopW - 50 * ss &&
        mouseY > shopY + 190 * ss && mouseY < shopY + 230 * ss) {
      if (satisfaction >= 5000 && !hasBanana) {
        satisfaction -= 5000;
        hasBanana = true;
        playBeep(800, 0.3);
        unlockAchievement("Why Did The Chicken Cross The Road?");
      }
      // Don't close the shop after purchase
      playBeep(400, 0.1);
      return;
    }
    
    // If we clicked in the shop but not on any buttons, don't do anything else
    if (mouseX > shopX && mouseX < shopX + shopW && 
        mouseY > shopY && mouseY < shopY + shopH) {
      return;
    } else {
      // Clicked outside shop - close it
      showShop = false;
      return;
    }
  }
  
  // If phone is hidden, don't process phone buttons
  if (phoneHidden) return;
  
  // Intensity buttons
  let btnW = (phoneW - 50 * s - 15 * s) / 4;
  for (let i = 0; i < 4; i++) {
    let bx = currentPhoneX + 25 * s + i * (btnW + 5 * s);
    let by = phoneY + 190 * s;
    if (mouseX > bx && mouseX < bx + btnW && mouseY > by && mouseY < by + 45 * s) {
      intensityLevel = i;
      playBeep(300 + i * 100, 0.1);
      return;
    }
  }
  
  // ACTIVATE WELLNESS button - the main event
  if (hitTest(mouseX, mouseY, bounds.activate)) {
    activateBtnPressed = true;
    activateWellness();
    return;
  }
  
  // Shop button
  if (hitTest(mouseX, mouseY, bounds.shop)) {
    showShop = true;
    playBeep(400, 0.1);
    return;
  }
  
  // Pair devices button
  if (hasBanana && !devicesPaired && hitTest(mouseX, mouseY, bounds.pair)) {
    devicesPaired = true;
    dualModeStartTime = millis();
    playPairingSound();
    unlockAchievement("Farm-to-Table Multitasking");
    return;
  }
}

function mouseDragged() {
  if (!showShop) {
    // NEW: Allow dragging on chicken when phone is hidden
    if (phoneHidden) {
      if (isClickOnChicken(mouseX, mouseY, currentChickenX, currentChickenY) ||
          (devicesPaired && hasBanana && isClickOnBanana(mouseX, mouseY, currentBananaX, currentBananaY))) {
        activateWellness();
      }
    } else {
      let currentPhoneX = phoneHideProgress === 0 ? originalPhoneX : 
                         phoneHideProgress === 1 ? targetPhoneX :
                         lerp(originalPhoneX, targetPhoneX, phoneHideProgress);
      let bounds = getButtonBounds(currentPhoneX, phoneY);
      if (hitTest(mouseX, mouseY, bounds.activate)) {
        activateWellness();
      }
    }
  }
}

function touchStarted() {
  mousePressed();
  return false;
}

function touchMoved() {
  mouseDragged();
  return false;
}

function activateWellness() {
  satisfaction += intensityMultipliers[intensityLevel];
  chickenShake = 5 + intensityLevel * 5;
  if (devicesPaired) bananaShake = 5 + intensityLevel * 5;
  if (frameCount % 5 === 0) playWellnessSound();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calculateLayout();
}

// A happy chicken is a productive chicken
// USDA compliance status: Pending Review
// Mobile optimization: HR Approved
</script>
</body>
</html>
